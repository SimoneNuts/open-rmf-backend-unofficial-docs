{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Open-RMF Backend Insights <p>Non solo un gateway: tutto ci\u00f2 che succede dietro le API di Open-RMF.</p>"},{"location":"#inizia-da-qui","title":"\ud83c\udf1f Inizia da qui","text":"<ul> <li>\ud83c\udfd7\ufe0f Architettura generale   Scopri la struttura e il flusso dati dell\u2019intero sistema.</li> <li>\ud83d\udd17 API Server   Tutto ci\u00f2 che serve sapere sul gateway tra frontend e Open-RMF.</li> <li>\ud83e\udd1d API Client   Il punto di accesso per integrare facilmente le API nel tuo progetto.</li> <li>\ud83d\udd0d Endpoints   Panoramica degli endpoint REST e WebSocket disponibili.</li> <li>\ud83d\udca1 Esempi d\u2019utilizzo   Casi d\u2019uso teorici e flussi tipici.</li> <li>\ud83d\udd12 Autenticazione &amp; sicurezza   Come vengono gestiti accessi, permessi e protezione dei dati.</li> </ul>"},{"location":"#cosa-offre-questa-guida","title":"\ud83d\uddc2\ufe0f Cosa offre questa guida","text":"<p>Indice delle sezioni</p> <ul> <li>Architettura: panoramica, diagrammi, flusso dati</li> <li>API Server: endpoints, configurazione, real-time, sicurezza</li> <li>API Client: uso pratico, esempi, tipizzazione</li> <li>Endpoints: REST &amp; WebSocket, parametri, risposte</li> <li>Esempi di codice: richieste reali, sottoscrizioni, autenticazione</li> <li>FAQ: domande frequenti, troubleshooting</li> </ul>"},{"location":"api-client/","title":"\ud83e\uddd1\u200d\ud83d\udcbb API Client","text":"<p>L\u2019API Client \u00e8 una componente concettuale fondamentale per l\u2019integrazione tra applicazioni esterne (come dashboard, microservizi, sistemi di orchestrazione) e l\u2019API Server del backend Open-RMF. Il suo scopo \u00e8 semplificare e standardizzare le interazioni, garantendo coerenza, sicurezza e facilit\u00e0 di evoluzione del sistema.</p>"},{"location":"api-client/#scopo-dellapi-client","title":"\ud83c\udfaf Scopo dell\u2019API Client","text":"<p>L\u2019API Client nasce per:</p> <ul> <li>Fornire un\u2019interfaccia chiara e documentata che rappresenti tutte le funzionalit\u00e0 esposte dall\u2019API Server.</li> <li>Centralizzare la logica di comunicazione verso il backend, evitando duplicazioni e facilitando la manutenzione.</li> <li>Favorire l\u2019integrabilit\u00e0 di dashboard, microservizi e strumenti di terze parti con Open-RMF in modo coerente e scalabile.</li> <li>Standardizzare la gestione di autenticazione, autorizzazione, errori e aggiornamenti in tempo reale.</li> </ul>"},{"location":"api-client/#caratteristiche-e-responsabilita","title":"\ud83e\udde9 Caratteristiche e responsabilit\u00e0","text":"<p>Punti chiave</p> <ul> <li>Astrazione delle API: l\u2019API Client espone metodi (o endpoint) che rappresentano le operazioni di business disponibili sul sistema (es. gestione flotte, task, risorse).</li> <li>Gestione delle chiamate asincrone e real-time: supporta sia operazioni sincrone (es. REST) che aggiornamenti/eventi asincroni (es. WebSocket).</li> <li>Sicurezza: centralizza la gestione di autenticazione (es. JWT/OIDC), autorizzazione e rinnovo token.</li> <li>Tipizzazione e validazione: definisce i contratti dati tra frontend/microservizi e backend, riducendo il rischio di errori.</li> <li>Unificazione degli errori: fornisce una gestione centralizzata degli errori e delle eccezioni di comunicazione.</li> </ul>"},{"location":"api-client/#vantaggi-dellapi-client","title":"\ud83c\udfc6 Vantaggi dell\u2019API Client","text":"<ul> <li>Manutenibilit\u00e0: aggiornare la logica di interazione con il backend richiede modifiche solo nell\u2019API Client, non su tutti i consumatori.</li> <li>Sicurezza: riduce il rischio di errori di autenticazione/autorizzazione grazie a una gestione centralizzata.</li> <li>Scalabilit\u00e0: semplifica l\u2019integrazione di nuovi frontend, microservizi e strumenti grazie a un\u2019interfaccia unica e documentata.</li> <li>Flessibilit\u00e0: l\u2019API Client pu\u00f2 essere adattato o esteso per supportare nuovi casi d\u2019uso o evoluzioni delle API backend.</li> </ul>"},{"location":"api-client/#ruolo-nellarchitettura","title":"\ud83c\udf10 Ruolo nell'architettura","text":"<p>L\u2019API Client si colloca come ponte tra i consumatori (frontend, microservizi, sistemi esterni) e l\u2019API Server. Rappresenta il punto di ingresso unico e controllato verso tutte le funzionalit\u00e0 di Open-RMF esposte tramite API.</p>"},{"location":"api-client/#sicurezza-e-conformita","title":"\ud83d\udd12 Sicurezza e conformit\u00e0","text":"<p>L\u2019API Client, essendo responsabile della comunicazione con il backend, \u00e8 il luogo ideale dove implementare:</p> <ul> <li>Gestione delle credenziali e dei token di accesso</li> <li>Refresh automatico dei token scaduti</li> <li>Verifiche sui permessi degli utenti</li> <li>Gestione centralizzata delle risposte di errore e delle eccezioni di sicurezza</li> </ul>"},{"location":"api-server/","title":"\ud83d\udda7 API Server","text":"<p>L\u2019API Server \u00e8 il cuore del backend Open-RMF e rappresenta il punto di contatto tra il mondo web (frontend, dashboard, microservizi) e il core Open-RMF (basato su ROS 2). Svolge il ruolo di gateway, orchestrando la comunicazione, la sicurezza e l\u2019esposizione delle funzionalit\u00e0 di alto livello.</p>"},{"location":"api-server/#scopo-dellapi-server","title":"\ud83c\udfaf Scopo dell\u2019API Server","text":"<p>L\u2019API Server nasce per:</p> <ul> <li>Esporre funzionalit\u00e0 RMF tramite API standard (REST e WebSocket), accessibili da dashboard, servizi esterni e client di vario tipo.</li> <li>Tradurre le richieste web (HTTP/WebSocket) in comunicazioni verso il core Open-RMF, che utilizza ROS 2 come middleware.</li> <li>Gestire autenticazione, autorizzazione e sicurezza di tutte le richieste.</li> <li>Fornire aggiornamenti in tempo reale su eventi e stati di robot, task, risorse e sistema.</li> </ul>"},{"location":"api-server/#responsabilita-principali","title":"\ud83e\udde9 Responsabilit\u00e0 principali","text":"<ul> <li>Gateway tra mondi: collega il mondo web (HTTP/REST/WebSocket) con il core robotico (ROS 2).</li> <li>API RESTful e real-time: offre endpoint sincroni (REST) e canali push (WebSocket) per la massima flessibilit\u00e0.</li> <li>Sicurezza centralizzata: gestisce autenticazione tramite OIDC/JWT, verifica permessi e ruoli, audita le operazioni.</li> <li>Configurabilit\u00e0: pu\u00f2 essere personalizzato per diversi deployment, supportando vari database e provider di autenticazione.</li> <li>Gestione utenti e permessi: mantiene uno strato di gestione utenti, ruoli e mapping con provider esterni.</li> </ul>"},{"location":"api-server/#vantaggi-architetturali","title":"\ud83c\udfc6 Vantaggi architetturali","text":"<ul> <li>Disaccoppiamento: i client non accedono mai direttamente a ROS 2, ma solo tramite API standard e sicure.</li> <li>Scalabilit\u00e0: ogni dashboard, microservizio o sistema terzo pu\u00f2 dialogare con Open-RMF senza conoscere i dettagli interni di ROS 2.</li> <li>Sicurezza: centralizza la gestione della sicurezza, riducendo la superficie di attacco e facilitando audit e compliance.</li> <li>Realtime: supporta notifiche push e aggiornamenti di stato in tempo reale tramite WebSocket.</li> </ul>"},{"location":"api-server/#posizionamento-nellarchitettura","title":"\ud83c\udf10 Posizionamento nell\u2019architettura","text":"<p>L\u2019API Server si trova tra il frontend (dashboard, microservizi, integrazioni) e il backend robotico Open-RMF. \u00c8 il solo punto di ingresso per tutte le richieste web ed \u00e8 responsabile di tradurle in azioni, task o query verso il core RMF.</p>"},{"location":"api-server/#sicurezza-e-gestione-accessi","title":"\ud83d\udd12 Sicurezza e gestione accessi","text":"<p>Tutto il traffico verso l\u2019API Server deve essere autenticato e autorizzato. L\u2019API Server: - Verifica l\u2019identit\u00e0 degli utenti tramite provider OIDC/JWT. - Applica policy di autorizzazione granulari (ruoli, permessi, mapping). - Pu\u00f2 essere configurato per audit, logging e compliance normativa.</p>"},{"location":"api-server/#configurabilita-e-deployment","title":"\ud83d\udee0\ufe0f Configurabilit\u00e0 e deployment","text":"<p>L\u2019API Server \u00e8 pensato per essere:</p> <ul> <li>Configurabile tramite file di configurazione o variabili ambiente.</li> <li>Portabile: pu\u00f2 essere containerizzato e orchestrato su Kubernetes/Docker.</li> <li>Adattabile: supporta pi\u00f9 database (SQLite, PostgreSQL) e vari provider di autenticazione.</li> </ul>"},{"location":"architecture/","title":"\ud83c\udfd7\ufe0f Architettura","text":"<p>Questa sezione offre una panoramica visiva e descrittiva dell\u2019architettura del backend Open-RMF, concentrandosi sull\u2019interazione tra i diversi componenti chiave: Frontend, API Server e Open-RMF Core (ROS 2).</p>"},{"location":"architecture/#schema-architetturale","title":"\ud83d\udcca Schema architetturale","text":"<pre><code>flowchart TD\n    subgraph Web\n        FE[Frontend_Client]\n    end\n    subgraph Backend\n        APIS[API_Server]\n        RMF[OpenRMF_Core]\n    end\n    FE -- REST_WebSocket --&gt; APIS\n    APIS -- ROS2_Topic_Service_Action --&gt; RMF</code></pre>"},{"location":"architecture/#descrizione-high-level","title":"\ud83d\udd0e Descrizione high-level","text":"<p>Come funziona il flusso</p> <ol> <li>Frontend: dashboard web, microservizi o app custom inviano richieste via REST o WebSocket verso l\u2019API Server.</li> <li>API Server: funge da gateway, espone API RESTful e WebSocket e traduce le richieste in chiamate ROS 2 verso Open-RMF.</li> <li>Open-RMF Core (ROS 2): gestisce flotte, task, risorse (porte, ascensori, robot, ecc.) e tutta la logica di orchestrazione.</li> </ol>"},{"location":"architecture/#componenti-principali","title":"\ud83e\udde9 Componenti principali","text":"<p>Frontend / Client</p> <ul> <li>Dashboard web o microservizi personalizzati</li> <li>Comunica solo tramite REST/WebSocket, mai direttamente con ROS 2</li> <li>Gestisce autenticazione e autorizzazione lato utente</li> </ul> <p>API Server</p> <ul> <li>Espone endpoint REST e canali WebSocket</li> <li>Traduce le richieste web in comunicazioni ROS 2</li> <li>Gestisce autenticazione (OIDC/JWT), permessi e ruoli</li> <li>Aggiorna i client in tempo reale sugli stati del sistema e dei robot</li> </ul> <p>Open-RMF Core (ROS 2)</p> <ul> <li>Scheduler, fleet adapters, task manager, resource manager, ecc.</li> <li>Comunica nativamente tramite ROS 2 (topic, servizi, azioni)</li> <li>Pu\u00f2 essere eseguito in simulazione o su robot reali</li> </ul>"},{"location":"architecture/#esempio-di-flusso-dati","title":"\ud83d\udd01 Esempio di flusso dati","text":"<p>Caso d\u2019uso: Creazione di un nuovo task</p> <ol> <li>L\u2019utente crea un task dalla dashboard \u2192 richiesta REST POST /tasks all\u2019API Server</li> <li>L\u2019API Server valida la richiesta, la traduce in una chiamata ROS 2 verso il task manager di Open-RMF</li> <li>Open-RMF pianifica il task e aggiorna lo stato </li> <li>L\u2019API Server riceve gli aggiornamenti e li invia in tempo reale al frontend via WebSocket</li> </ol>"},{"location":"architecture/#vantaggi-di-questa-architettura","title":"\ud83d\udee0\ufe0f Vantaggi di questa architettura","text":"<ul> <li>Disaccoppiamento: il frontend non interagisce mai direttamente con ROS 2, migliorando sicurezza e scalabilit\u00e0.</li> <li>Real-time: aggiornamenti push tramite WebSocket. </li> <li>Scalabilit\u00e0: ogni componente pu\u00f2 essere containerizzato e scalato separatamente. </li> <li>Interoperabilit\u00e0: il gateway via REST/WebSocket permette l\u2019integrazione con altri sistemi IT, microservizi, dashboard custom, ecc.</li> </ul>"},{"location":"architecture/#domande-frequenti","title":"\u2753 Domande frequenti","text":"<p>Posso collegare pi\u00f9 frontend allo stesso backend?</p> <p>S\u00ec, l\u2019architettura supporta pi\u00f9 client contemporanei (dashboard, microservizi, sistemi esterni).</p> <p>Il backend pu\u00f2 funzionare sia con robot reali sia in simulazione?</p> <p>S\u00ec, Open-RMF \u00e8 pensato per funzionare indifferentemente in ambiente reale o simulato, senza modifiche architetturali.</p> <p>E se volessi integrare un altro sistema IT (WMS, ERP, ecc.)?</p> <p>Puoi farlo creando microservizi che comunicano via REST/WebSocket con l\u2019API Server.</p>"},{"location":"authentication/","title":"\ud83d\udd12 Autenticazione &amp; Sicurezza","text":"<p>L\u2019autenticazione e la sicurezza rappresentano pilastri fondamentali nell\u2019architettura del backend Open-RMF. L\u2019API Server si occupa di garantire che solo utenti e servizi autorizzati possano accedere e interagire con le funzionalit\u00e0 esposte.</p>"},{"location":"authentication/#obiettivi-dellautenticazione","title":"\ud83c\udfaf Obiettivi dell\u2019autenticazione","text":"<ul> <li>Verificare l\u2019identit\u00e0 degli utenti e dei servizi che accedono alle API.</li> <li>Proteggere i dati e le funzionalit\u00e0 critiche da accessi non autorizzati.</li> <li>Gestire permessi granulari tramite ruoli e policy.</li> <li>Tracciare le operazioni per audit e compliance.</li> </ul>"},{"location":"authentication/#principi-architetturali","title":"\ud83c\udfdb\ufe0f Principi architetturali","text":"<ul> <li>Single Point of Authentication: tutto il traffico verso l\u2019API Server passa attraverso un meccanismo di autenticazione centralizzato.</li> <li>Standard moderni: si utilizzano protocolli come OpenID Connect (OIDC) e JSON Web Token (JWT), compatibili con i principali identity provider.</li> <li>Gestione dei permessi: ogni utente/servizio \u00e8 associato a ruoli che definiscono le operazioni consentite.</li> </ul>"},{"location":"authentication/#come-funziona-nel-backend-open-rmf","title":"\ud83e\udde9 Come funziona nel backend Open-RMF","text":"<ol> <li>Autenticazione tramite provider OIDC    L\u2019utente o servizio effettua il login presso un identity provider (es. Keycloak, Auth0, Azure AD) e ottiene un token JWT.</li> <li>Accesso alle API    Tutte le chiamate REST e WebSocket devono includere il token JWT nell\u2019header di autorizzazione.</li> <li>Validazione e autorizzazione    L\u2019API Server valida il token, verifica i permessi (ruoli, policy), e consente o nega la richiesta.</li> <li>Gestione sessione e rinnovo token    In caso di token scaduti o non validi, vengono rifiutate le richieste e, se supportato, pu\u00f2 essere attivato un meccanismo di refresh.</li> </ol>"},{"location":"authentication/#ruoli-e-permessi","title":"\ud83d\udd10 Ruoli e permessi","text":"<ul> <li>Ogni utente o servizio pu\u00f2 essere associato a uno o pi\u00f9 ruoli (es. admin, operator, viewer).</li> <li>Le operazioni disponibili (es. creazione task, visualizzazione stato, gestione risorse) dipendono dai permessi associati al ruolo.</li> <li>La mappatura ruoli/permessi \u00e8 configurabile e pu\u00f2 essere integrata con i sistemi di identity aziendali.</li> </ul>"},{"location":"authentication/#flusso-tipico-di-autenticazione","title":"\ud83d\udccb Flusso tipico di autenticazione","text":"<pre><code>sequenceDiagram\n    participant U as Utente/Servizio\n    participant IDP as Identity Provider (OIDC)\n    participant API as API Server\n    U-&gt;&gt;IDP: Login (credenziali)\n    IDP--&gt;&gt;U: Token JWT\n    U-&gt;&gt;API: Chiamata API (Authorization: Bearer &lt;token&gt;)\n    API-&gt;&gt;IDP: Verifica token (se necessario)\n    API--&gt;&gt;U: Risposta (autorizzato o negato)</code></pre>"},{"location":"authentication/#best-practice","title":"\ud83d\udee1\ufe0f Best Practice","text":"<ul> <li>Proteggi sempre il traffico con HTTPS/TLS.</li> <li>Configura la scadenza dei token e un meccanismo di refresh sicuro.</li> <li>Limita i permessi solo a ci\u00f2 che \u00e8 necessario per ogni ruolo.</li> <li>Traccia tutte le operazioni sensibili per audit e sicurezza.</li> <li>Integra l\u2019autenticazione con l\u2019infrastruttura aziendale quando possibile (SSO, LDAP, ecc.).</li> </ul>"},{"location":"authentication/#domande-frequenti","title":"\u2753 Domande frequenti","text":"<p>Cosa succede se il token non \u00e8 valido o scaduto?</p> <p>L\u2019API Server rifiuta la richiesta con un errore di autenticazione e non esegue nessuna operazione.</p> <p>Posso usare diversi provider OIDC?</p> <p>S\u00ec, l\u2019API Server pu\u00f2 essere configurato per supportare diversi provider compatibili con OIDC/JWT.</p> <p>I permessi sono configurabili?</p> <p>S\u00ec, ruoli e permessi sono personalizzabili e possono essere mappati secondo le policy aziendali.</p>"},{"location":"endpoints/","title":"\ud83d\udd17 Endpoints","text":"<p>Gli endpoint rappresentano i punti di accesso offerti dall\u2019API Server per interagire con il backend Open-RMF. Sono progettati per esporre funzionalit\u00e0 in modo standardizzato, sicuro e scalabile sia tramite chiamate sincrone (REST) che aggiornamenti in tempo reale (WebSocket).</p>"},{"location":"endpoints/#tipologie-di-endpoint","title":"\ud83e\udded Tipologie di endpoint","text":"<ul> <li> <p>REST API</p> <ul> <li>Permettono operazioni sincrone: invio di richieste e ricezione di una risposta immediata.</li> <li>Ideali per operazioni di lettura, scrittura o modifica di risorse (es. flotte, task, robot, porte).</li> </ul> </li> <li> <p>WebSocket / Event Streams</p> <ul> <li>Permettono una comunicazione asincrona e bidirezionale.</li> <li>Utilizzate per ricevere aggiornamenti in tempo reale su stati di robot, task, eventi di sistema, ecc.</li> </ul> </li> </ul>"},{"location":"endpoints/#struttura-degli-endpoint-rest","title":"\ud83d\uddc2\ufe0f Struttura degli endpoint REST","text":"<p>Principali risorse REST</p> <ul> <li>/fleets: gestione e interrogazione delle flotte robotiche disponibili.</li> <li>/robots: informazioni e stato dei singoli robot.</li> <li>/tasks: creazione, aggiornamento e monitoraggio dei task.</li> <li>/doors: stato e controllo delle porte automatizzate.</li> <li>/lifts: gestione e monitoraggio degli ascensori.</li> <li>/users: (se implementato) gestione utenti, ruoli, permessi.</li> </ul>"},{"location":"endpoints/#canali-websocketevent-streams","title":"\ud83c\udf10 Canali WebSocket/Event Streams","text":"<p>Principali canali WebSocket</p> <ul> <li>robot_states: aggiornamenti in tempo reale sullo stato dei robot.</li> <li>task_states: evoluzione e stato corrente dei task.</li> <li>door_states: stato delle porte in tempo reale.</li> <li>lift_states: stato degli ascensori.</li> <li>event_logs: eventi e notifiche di sistema.</li> </ul>"},{"location":"endpoints/#ruolo-degli-endpoint-nellarchitettura","title":"\ud83c\udfc6 Ruolo degli endpoint nell\u2019architettura","text":"<p>Gli endpoint rappresentano il \u201ccontratto\u201d tra il mondo esterno e il backend Open-RMF. Permettono a dashboard, microservizi e sistemi esterni di eseguire operazioni, ricevere informazioni aggiornate e integrarsi in modo sicuro e standardizzato.</p>"},{"location":"endpoints/#esempi-di-operazioni","title":"\ud83d\udccb Esempi di operazioni","text":""},{"location":"endpoints/#panoramica-teorica","title":"\ud83e\udded Panoramica teorica","text":"<ul> <li>Ottenere la lista delle flotte disponibili  </li> <li>Creare un nuovo task  </li> <li>Recuperare lo stato corrente di un robot  </li> <li>Modificare lo stato di una risorsa (es. apertura porta)</li> </ul>"},{"location":"endpoints/#reference-completo-degli-endpoint","title":"\ud83e\udde9 Reference completo degli Endpoint","text":"<p>Qui sotto trovi tutti gli endpoint dettagliati con metodi, path, parametri ed esempi</p> <p>Quick start</p> <ul> <li>Base URL: <code>http://localhost:8000</code> </li> <li>Live Swagger UI: http://localhost:8000/docs </li> <li>OpenAPI JSON: http://localhost:8000/openapi.json</li> </ul>"},{"location":"endpoints/#schema-ad-alto-livello","title":"\ud83d\udcca Schema ad Alto Livello","text":"<pre><code>flowchart LR\n    subgraph Client\n        A[Dashboard / Client]\n    end\n\n    subgraph API\n        AL[Alert] \n        DO[Porte] \n        LI[Ascensori] \n        TA[Task] \n        SC[Pianificati] \n        FL[Flotte] \n        AD[Admin] \n    end\n\n    A --&gt; AL\n    A --&gt; DO\n    A --&gt; LI\n    A --&gt; TA\n    A --&gt; SC\n    A --&gt; FL\n    A --&gt; AD\n\n    AL -- \"POST /alerts/request\" --&gt; AR[Crea Alert]\n    DO -- \"POST /doors/{name}/request\" --&gt; DR[Richiedi porta]\n    LI -- \"POST /lifts/{name}/request\" --&gt; LR[Richiedi ascensore]\n    TA -- \"POST /tasks/dispatch_task\" --&gt; TD[Invia task]\n    SC -- \"POST /scheduled_tasks\" --&gt; SCr[Crea pianificato]\n    FL -- \"GET /fleets\" --&gt; FLs[Elenco flotte]\n    AD -- \"POST /admin/users\" --&gt; AUs[Crea utente]</code></pre>"},{"location":"endpoints/#autenticazione","title":"\ud83d\udd10 Autenticazione","text":"<p>Tutti gli endpoint (eccetto <code>/socket.io</code>) richiedono un token Bearer ottenuto dal tuo IdP OpenID Connect.</p> <pre><code>Authorization: Bearer &lt;jwt&gt;\n</code></pre>"},{"location":"endpoints/#catalogo-endpoint","title":"\ud83d\udcc1 Catalogo Endpoint","text":""},{"location":"endpoints/#alert-alerts","title":"\ud83d\udea8 Alert (<code>/alerts</code>)","text":"<p>Concept</p> <p>Gli alert sono notifiche interattive mostrate agli operatori (allarme antincendio, batteria scarica, ecc.).</p> Metodo Percorso Descrizione Corpo richiesta <code>POST</code> <code>/alerts/request</code> Crea nuovo alert <code>AlertRequest</code> <code>GET</code> <code>/alerts/request/{alert_id}</code> Leggi singolo alert \u2014 <code>POST</code> <code>/alerts/request/{alert_id}/respond</code> Rispondi a un alert <code>{\"response\": \"ack\"}</code> <code>GET</code> <code>/alerts/requests/task/{task_id}</code> Alert relativi a un task \u2014 <code>GET</code> <code>/alerts/unresponded_requests</code> Alert ancora da rispondere \u2014 Example \u2013 Crea un alert <pre><code>curl -X POST http://localhost:8000/alerts/request \\\n  -H \"Authorization: Bearer $TOKEN\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"title\": \"Fuoco al piano 1\",\n    \"message\": \"Evacuazione immediata\",\n    \"tier\": \"critical\",\n    \"display\": true\n  }'\n</code></pre>"},{"location":"endpoints/#porte-doors-doors","title":"\ud83d\udeaa Porte \u2013 Doors (<code>/doors</code>)","text":"Metodo Percorso Descrizione Corpo <code>GET</code> <code>/doors</code> Elenca tutte le porte \u2014 <code>GET</code> <code>/doors/{name}/state</code> Stato attuale di una porta \u2014 <code>POST</code> <code>/doors/{name}/request</code> Apri / Chiudi <code>{\"mode\": 2}</code> Modalit\u00e0 porta Valore Significato <code>0</code> Chiusa <code>1</code> In movimento <code>2</code> Aperta"},{"location":"endpoints/#ascensori-lifts-lifts","title":"\ud83d\uded7 Ascensori \u2013 Lifts (<code>/lifts</code>)","text":"Metodo Percorso Descrizione Corpo <code>GET</code> <code>/lifts</code> Elenca ascensori \u2014 <code>GET</code> <code>/lifts/{name}/state</code> Stato + piano attuale \u2014 <code>POST</code> <code>/lifts/{name}/request</code> Chiama / sposta ascensore <code>LiftRequest</code>"},{"location":"endpoints/#task-tasks","title":"\ud83d\udcdd Task (<code>/tasks</code>)","text":"Metodo Percorso Descrizione Corpo <code>POST</code> <code>/tasks/dispatch_task</code> Invia nuovo task <code>DispatchTaskRequest</code> <code>POST</code> <code>/tasks/cancel_task</code> Annulla task in corso <code>{\"task_id\": \"uuid\"}</code> <code>GET</code> <code>/tasks/requests</code> Lista delle richieste task \u2014 <code>GET</code> <code>/tasks/{task_id}/state</code> Stato di un singolo task \u2014 <code>GET</code> <code>/tasks/{task_id}/log</code> Log eventi del task \u2014"},{"location":"endpoints/#task-pianificati-scheduled-tasks-scheduled_tasks","title":"\ud83d\udcc5 Task pianificati \u2013 Scheduled Tasks (<code>/scheduled_tasks</code>)","text":"Metodo Percorso Descrizione Corpo <code>POST</code> <code>/scheduled_tasks</code> Crea task ricorrente <code>ScheduledTaskRequest</code> <code>GET</code> <code>/scheduled_tasks</code> Lista task pianificati \u2014 <code>GET</code> <code>/scheduled_tasks/{id}</code> Dettaglio singola pianificazione \u2014 <code>DELETE</code> <code>/scheduled_tasks/{id}</code> Elimina pianificazione \u2014"},{"location":"endpoints/#flotte-e-robot-fleets-fleets","title":"\ud83d\ude9b Flotte e robot \u2013 Fleets (<code>/fleets</code>)","text":"Metodo Percorso Descrizione <code>GET</code> <code>/fleets</code> Tutte le flotte e i robot <code>GET</code> <code>/fleets/{name}/state</code> Stato flotta (robot, batteria, problemi\u2026) <code>POST</code> <code>/fleets/{name}/decommission</code> Metti robot fuori servizio <code>POST</code> <code>/fleets/{name}/recommission</code> Riporta robot in servizio"},{"location":"endpoints/#amministrazione-admin-admin","title":"\u2699\ufe0f Amministrazione \u2013 Admin (<code>/admin</code>)","text":"<p>Richiede ruolo admin</p> Metodo Percorso Descrizione <code>GET</code> <code>/admin/users</code> Elenca utenti <code>POST</code> <code>/admin/users</code> Crea utente <code>PUT</code> <code>/admin/users/{u}/roles</code> Sostituisci ruoli <code>POST</code> <code>/admin/roles</code> Crea ruolo <code>POST</code> <code>/admin/roles/{r}/permissions</code> Aggiungi permesso"},{"location":"endpoints/#schemi-comuni","title":"\ud83d\udce6 Schemi comuni","text":""},{"location":"endpoints/#alertrequest","title":"<code>AlertRequest</code>","text":"<pre><code>{\n  \"title\": \"string\",\n  \"message\": \"string\",\n  \"tier\": \"info | warning | critical\",\n  \"display\": true,\n  \"responses_available\": [\"ack\", \"ignore\"]\n}\n</code></pre>"},{"location":"endpoints/#dispatchtaskrequest","title":"<code>DispatchTaskRequest</code>","text":"<pre><code>{\n  \"category\": \"patrol\",\n  \"description\": {\"zone\": \"L1_corridor\"},\n  \"fleet_name\": \"tinyRobot\",\n  \"priority\": {\"type\": \"binary\", \"value\": 1},\n  \"requester\": \"dashboard\"\n}\n</code></pre>"},{"location":"endpoints/#liftrequest","title":"<code>LiftRequest</code>","text":"<pre><code>{\n  \"request_type\": 1,\n  \"destination\": \"L2\",\n  \"door_mode\": 0\n}\n</code></pre>"},{"location":"endpoints/#scheduledtaskrequest","title":"<code>ScheduledTaskRequest</code>","text":"<pre><code>{\n  \"task_request\": { /* stesso di DispatchTaskRequest */ },\n  \"schedules\": [\n    { \"every\": 1, \"period\": \"day\", \"at\": \"09:00\" }\n  ],\n  \"start_from\": \"2025-07-30T09:00:00Z\",\n  \"until\": \"2025-12-31\"\n}\n</code></pre>"},{"location":"endpoints/#script-di-prova-rapida","title":"\ud83e\uddea Script di prova rapida","text":"<p>Salva come <code>test_api.sh</code>, inserisci il tuo <code>$TOKEN</code>.</p> <pre><code>#!/usr/bin/env bash\nHOST=\"http://localhost:8000\"\nTOKEN=\"IL_TUO_JWT\"\n\n# Lista flotte\ncurl -sS -H \"Authorization: Bearer $TOKEN\" $HOST/fleets | jq .\n\n# Invia task di prova\ncurl -sS -H \"Authorization: Bearer $TOKEN\" \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"category\":\"patrol\",\"description\":{\"zone\":\"corridoio_L1\"},\"fleet_name\":\"tinyRobot\"}' \\\n     $HOST/tasks/dispatch_task | jq .\n</code></pre>"},{"location":"endpoints/#sicurezza-degli-endpoint","title":"\ud83d\udd12 Sicurezza degli endpoint","text":"<p>Tutti gli endpoint sono protetti tramite autenticazione (es. JWT/OIDC) e autorizzazione basata su ruoli e permessi. L\u2019accesso a specifici endpoint o canali pu\u00f2 essere limitato in base al profilo utente.</p>"},{"location":"endpoints/#domande-frequenti","title":"\u2753 Domande frequenti","text":"<p>Posso estendere o personalizzare gli endpoint?</p> <p>S\u00ec, l\u2019API Server pu\u00f2 essere configurato o esteso per offrire endpoint aggiuntivi o personalizzati.</p> <p>Come vengono versionati gli endpoint?</p> <p>\u00c8 buona pratica includere la versione nell\u2019URL (es. <code>/v1/fleets</code>), facilitando l\u2019evoluzione senza rompere la retrocompatibilit\u00e0.</p> <p>Come funzionano le sottoscrizioni agli eventi?</p> <p>Di norma, il client si connette via WebSocket e si sottoscrive ai canali di interesse, ricevendo aggiornamenti dal server in tempo reale.</p>"},{"location":"examples/","title":"\ud83d\udca1 Esempi di utilizzo","text":"<p>Questa sezione descrive casi d\u2019uso teorici e flussi di interazione tipici tra client (dashboard, microservizi) e backend Open-RMF tramite l\u2019API Server. Gli esempi forniscono spunti concreti su come sfruttare le API REST e i canali WebSocket per la gestione di flotte, task, risorse e monitoraggio in tempo reale.</p>"},{"location":"examples/#esempi-di-casi-duso","title":"\ud83d\ude80 Esempi di casi d\u2019uso","text":""},{"location":"examples/#1-monitoraggio-stato-flotte-e-robot-in-tempo-reale","title":"1. Monitoraggio stato flotte e robot in tempo reale","text":"<p>Un sistema di supervisione o una dashboard si collega all\u2019API Server, si autentica e si sottoscrive ai canali WebSocket di stato (<code>robot_states</code>, <code>fleet_states</code>). In questo modo, l\u2019operatore visualizza aggiornamenti continui su posizione, carica, stato operativo e anomalie di ogni robot o flotta.</p>"},{"location":"examples/#2-creazione-e-supervisione-di-un-nuovo-task","title":"2. Creazione e supervisione di un nuovo task","text":"<p>Un utente autorizzato accede alla dashboard, compila un form per assegnare un nuovo compito (es. trasporto di un oggetto). La richiesta viene inoltrata all\u2019API Server tramite un endpoint REST (<code>/tasks</code>) e, una volta creato il task, il client si sottoscrive al canale <code>task_states</code> per seguirne l\u2019avanzamento in tempo reale.</p>"},{"location":"examples/#3-gestione-di-risorse-porte-ascensori","title":"3. Gestione di risorse (porte, ascensori)","text":"<p>Attraverso endpoint REST dedicati, \u00e8 possibile interrogare lo stato di una porta o di un ascensore, oppure inviare comandi di apertura/chiusura o chiamata. Il client monitora lo stato aggiornato della risorsa tramite i canali <code>door_states</code> o <code>lift_states</code> via WebSocket.</p>"},{"location":"examples/#4-notifiche-di-eventi-e-allarmi","title":"4. Notifiche di eventi e allarmi","text":"<p>Un microservizio o una dashboard pu\u00f2 sottoscriversi al canale di eventi (<code>event_logs</code>) per ricevere notifiche istantanee su anomalie, allarmi di sicurezza, completamento task, interventi manuali o problemi di sistema.</p>"},{"location":"examples/#5-gestione-multi-utente-e-permessi","title":"5. Gestione multi-utente e permessi","text":"<p>L\u2019API Server consente a pi\u00f9 utenti, ognuno con ruoli e permessi diversi, di accedere alle stesse API. Ad esempio, un \u201coperatore\u201d pu\u00f2 creare e monitorare task, mentre un \u201camministratore\u201d pu\u00f2 anche gestire flotte, risorse e configurazioni avanzate.</p>"},{"location":"examples/#flusso-generale-di-interazione","title":"\ud83d\udd04 Flusso generale di interazione","text":"<p>Esempio di flusso tipico</p> <ol> <li>Autenticazione: Il client ottiene un token da un provider OIDC e lo invia all\u2019API Server.</li> <li>Richiesta REST: Il client effettua una richiesta (ad es. creazione task, interrogazione stato robot).</li> <li>Sottoscrizione WebSocket: Il client si collega e si sottoscrive ai canali di interesse per ricevere aggiornamenti in tempo reale.</li> <li>Gestione risposte e aggiornamenti: Il client aggiorna la UI o i dati interni in base alle risposte e agli eventi ricevuti.</li> </ol>"},{"location":"examples/#benefici-di-questi-flussi","title":"\ud83c\udfc6 Benefici di questi flussi","text":"<ul> <li>Esperienza utente migliorata: aggiornamenti in tempo reale e interfacce reattive.</li> <li>Automazione: possibilit\u00e0 di integrare sistemi esterni e microservizi per gestire flotte e task senza intervento manuale.</li> <li>Sicurezza: ogni interazione \u00e8 soggetta a controlli di autenticazione e autorizzazione.</li> <li>Scalabilit\u00e0: il modello \u00e8 adatto sia a piccoli impianti che a grandi installazioni multi-flotta.</li> </ul>"},{"location":"examples/#domande-frequenti","title":"\u2753 Domande frequenti","text":"<p>Posso combinare pi\u00f9 canali WebSocket?</p> <p>S\u00ec, un client pu\u00f2 sottoscriversi a pi\u00f9 canali contemporaneamente per ottenere una panoramica completa e aggiornata del sistema.</p> <p>Gli esempi sono validi sia in simulazione che in produzione?</p> <p>Assolutamente s\u00ec: l\u2019architettura Open-RMF consente di usare gli stessi flussi sia su robot reali che in ambienti simulati.</p> <p>Questi esempi coprono tutti i casi d\u2019uso?</p> <p>Sono solo spunti: l\u2019API Server \u00e8 pensato per essere esteso e adattato a molti scenari diversi.</p>"},{"location":"microapp-dataflow/","title":"Micro-app Data Flow","text":""},{"location":"microapp-dataflow/#flusso-dati-delle-micro-app-rmf-dashboard-framework","title":"\ud83e\udde9 Flusso dati delle Micro-App (rmf-dashboard-framework)","text":"<p>Tutte le micro-app ricevono e interpretano i dati tramite l\u2019hook useRmfApi(), che restituisce un\u2019istanza di <code>RmfApi</code>. Di seguito il dettaglio per micro-app (file, chiamata, parsing).</p>"},{"location":"microapp-dataflow/#robots","title":"\ud83e\udd16 Robots","text":"<p>File: robots-table.tsx Flusso: <pre><code>const rmfApi = useRmfApi();\nconst fleets = await rmfApi.fleetsApi.getFleetsFleetsGet();\nconst tasks   = await rmfApi.tasksApi.queryTaskStatesTasksGet();\n</code></pre></p> <p>Usa l\u2019hook <code>useRmfApi</code> per ottenere l\u2019istanza di API. Recupera le flotte e i robot tramite <code>rmfApi.fleetsApi.getFleetsFleetsGet()</code>.</p> <ul> <li>Parsing: i payload vengono mappati nel tipo <code>RobotTableData</code>.  </li> <li>Sorgente: REST <code>/fleets</code> + <code>/tasks</code>.</li> </ul>"},{"location":"microapp-dataflow/#map","title":"\ud83d\uddfa\ufe0f Map","text":"<p>File: map.tsx Flusso: <pre><code>const buildingMap$ = rmfApi.buildingMapObs;\nconst fleets$      = rmfApi.fleetsObs;\n</code></pre></p> <p>Sottoscrive a <code>rmfApi.buildingMapObs</code> per la mappa dell\u2019edificio. Sottoscrive a <code>rmfApi.fleetsObs</code> per flotte e robot.</p> <ul> <li>Parsing: oggetti <code>RobotData</code>, <code>Place</code> estratti dagli observable RxJS.  </li> <li>Sorgente: WebSocket (building map + posizione robot).</li> </ul>"},{"location":"microapp-dataflow/#doors","title":"\ud83d\udeaa Doors","text":"<p>File: doors-table.tsx Flusso: <pre><code>const doors$ = rmfApi.doorsObs;\n</code></pre></p> <p>Usa <code>rmfApi.doorsObs</code> per ottenere la lista delle porte. I dati sono gi\u00e0 in formato array di Door e vengono visualizzati direttamente.</p> <ul> <li>Parsing: array <code>Door[]</code> gi\u00e0 tipizzato.  </li> <li>Sorgente: WebSocket <code>/doors</code>.</li> </ul>"},{"location":"microapp-dataflow/#lifts","title":"\ud83d\uded7 Lifts","text":"<p>File: lifts-table.tsx Flusso: <pre><code>const lifts$ = rmfApi.liftsObs;\n</code></pre></p> <p>Usa <code>rmfApi.liftsObs</code> per ottenere la lista degli ascensori. I dati sono gi\u00e0 in formato array di Lift.</p> <ul> <li>Parsing: array <code>Lift[]</code> pronto per la tabella.  </li> <li>Sorgente: WebSocket <code>/lifts</code>.</li> </ul>"},{"location":"microapp-dataflow/#task","title":"\ud83d\udcdd Task","text":"<p>File: tasks-window.tsx Flusso: <pre><code>const tasks = await rmfApi.tasksApi.queryTaskStatesTasksGet();\n</code></pre></p> <p>Recupera i task tramite <code>rmfApi.tasksApi.queryTaskStatesTasksGet()</code>. I dati vengono mappati in oggetti <code>TaskState</code> e visualizzati.</p> <ul> <li>Parsing: oggetti <code>TaskState</code>; per l\u2019export CSV viene usato <code>utils.ts</code>.  </li> <li>Sorgente: REST <code>/tasks</code>.</li> </ul>"},{"location":"microapp-dataflow/#mutex-groups","title":"\ud83d\udd12 Mutex Groups","text":"<p>File: robot-mutex-group-table.tsx Flusso: <pre><code>const fleets = await rmfApi.fleetsApi.getFleetsFleetsGet();\nconst mutexGroups = extractMutexGroups(fleets);\n</code></pre></p> <p>Recupera le flotte tramite <code>rmfApi.fleetsApi.getFleetsFleetsGet()</code>. Estrae i gruppi mutex dai dati dei robot tramite mapping.</p> <ul> <li>Parsing: estrazione manuale dai dati flotta.  </li> <li>Sorgente: REST <code>/fleets</code>.</li> </ul>"},{"location":"microapp-dataflow/#parsing-generale","title":"\ud83e\uddf0 Parsing generale","text":"<ul> <li>Tipizzazione TypeScript: ogni dato \u00e8 tipizzato (es. <code>RobotState</code>, <code>TaskState</code>, <code>Door</code>, ecc.).</li> <li>Funzioni di utilit\u00e0: per estrarre o trasformare dati (es. <code>getTaskBookingLabelFromTaskState</code>).</li> <li>Observable: i dati sono spesso forniti come observable e aggiornati in tempo reale.</li> </ul>"}]}